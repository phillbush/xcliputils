.Dd March 6, 2023
.Dt CTRLSEL 3
.Os
.Sh NAME
.Nm ctrlsel_filltarget ,
.Nm ctrlsel_request ,
.Nm ctrlsel_receive ,
.Nm ctrlsel_cancel ,
.Nm ctrlsel_setowner ,
.Nm ctrlsel_send ,
.Nm ctrlsel_disown
.Nd X11 selection ownership and requesting helper functions
.Sh SYNOPSIS
.In "X11/Xlib.h"
.In "control/ctrlsel.h"
.Ft void
.Fo "ctrlsel_filltarget"
.Fa "Atom target"
.Fa "Atom type"
.Fa "int format"
.Fa "unsigned char *buffer"
.Fa "unsigned long size"
.Fa "struct CtrlSelTarget *target_fill"
.Fc
.Ft int
.Fo "ctrlsel_request"
.Fa "Display *display"
.Fa "Window window"
.Fa "Atom selection"
.Fa "Time time"
.Fa "struct CtrlSelTarget targets[]"
.Fa "unsigned long ntargets"
.Fa "struct CtrlSelContext *context"
.Fc
.Ft int
.Fo "ctrlsel_receive"
.Fa "struct CtrlSelContext *context"
.Fa "XEvent *event"
.Fc
.Ft void
.Fo "ctrlsel_cancel"
.Fa "struct CtrlSelContext *context"
.Fc
.Ft int
.Fo "ctrlsel_setowner"
.Fa "Display *display"
.Fa "Window window"
.Fa "Atom selection"
.Fa "Time time"
.Fa "int ismanager"
.Fa "struct CtrlSelTarget targets[]"
.Fa "unsigned long ntargets"
.Fa "struct CtrlSelContext *context"
.Fc
.Ft int
.Fo "ctrlsel_send"
.Fa "struct CtrlSelContext *context"
.Fa "XEvent *event"
.Fc
.Ft void
.Fo "ctrlsel_disown"
.Fa "struct CtrlSelContext *context"
.Fc
.Sh ARGUMENTS
.Bl -tag -width Ds
.It Fa "buffer"
Specifies the data of the selection in the target.
If the
.Fa "target_fill"
argument is for a selection to be owned,
.Fa buffer
should exist (not be freed) until the selection is lost or disowned.
If the
.Fa "target_fill"
argument is for a selection to be requested,
then any value (such as
.Ic "NULL" )
can be given, for the selection content is yet to be requested.
.It Fa "context"
Specifies the data relevant for the selection request or ownership.
.It Fa "display"
Specifies the connection to the X server.
.It Fa "event"
Specifies the pointer to a
.Ft "XEvent"
to be filtered.
.It Fa "format"
Specifies the format of each member of the selection content converted into the target.
It should be either
.Ic "8"
.Pq Ft "char" ,
.Ic "16"
.Pq Ft "short" ,
or
.Ic "32"
.Pq Ft "long" .
This argument need only be set when the
.Fa "target_fill"
argument is for a selection to be owned (given to
.Fn "ctrlsel_setowner" ) ,
for the content type is already known.
If
.Fa "target_fill"
is for a selection to be requested (that is, given to
.Fn "ctrlsel_request" ) ,
then any value (such as
.Ic "0" )
can be given,
for the format is not known yet.
.It Fa "ismanager"
Specifies whether the selection whose ownership is being asked by
.Fn "ctrlsel_setowner"
is a manager selection.
.It Fa "ntargets"
Specifies the number of members of the
.Fa targets
array.
.It Fa "selection"
Specifies the atom identifying the requested selection (for
.Fn "ctrlsel_request" ) ,
or the selection to be owned (for
.Fn "ctrlsel_setowner" ) .
.It Fa "size"
Specifies the size, in bytes, of
.Fa "buffer" .
Ignored if the target is to be requested.
.It Fa "target"
Specifies the atom identifying a target which the selection can be converted to.
.It Fa "target_fill"
Specifies the pointer to a
.Ft "struct CtrlSelTarget"
structure whose members will be defined.
.It Fa "time"
specifies the timestamp of the selection request (for
.Fn "ctrlsel_request" )
or the selection ownership (for
.Fn "ctrlsel_setowner" ) .
.It Fa "type"
Specifies the atom identifying the type of the content of the selection in the target.
It is usually the same atom as the target.
This argument need only be set when the
.Fa "target_fill"
argument is for a selection to be owned (that is, given to
.Fn "ctrlsel_setowner" ) ,
for the content is already converted into the target.
If
.Fa "target_fill"
is for a selection to be requested (that is, given to
.Fn "ctrlsel_request" ) ,
then any value (such as
.Ic "None" )
can be given, for the type is not known yet.
.It Fa "window"
Specifies the window requesting (for
.Fn "ctrlsel_request" )
or willing to own (for
.Fn "ctrlsel_setowner" )
the given
.Fa "selection" .
.El
.Sh DESCRIPTION
.Pp
The
.Fn ctrlsel_filltarget
function fills in the members of the
.Fa "target_fill"
structure with the values given in as arguments and other values computed from those.
.Fa "target_fill"
could be initialized or assigned manually by the programmer; however it is recommended to use the
.Fn ctrlsel_filltarget
function instead because it both provides compile-time checking of whether all the members have been properly assigned,
and also compute and defines the
.Fn "nitems"
member, which is derived from the other ones.
.Pp
The
.Fn "ctrlsel_request"
function requests for the
.Xr Xserver 1
represented by
.Fa "display"
to convert the
.Fa "selection"
into all the
.Fa "targets"
in name of the
.Fa "window" .
This function also fills
.Fa "context"
with data to be passed to the
.Fn "ctrlsel_receive"
and
.Fn "ctrlsel_cancel"
functions.
It returns nonzero on success or zero on error.
.Pp
The
.Fn "ctrlsel_receive"
function filters the X event pointed to by
.Fa "event" ,
checks whether it is related to the
.Fa "context"
previously filled in by
.Fn "ctrlsel_request" ,
and receives part of or all the content of the requested selection into the requested targets.
One of the following enum constants is returned:
.Bl -tag -width Ds
.It Ic "CTRLSEL_NONE"
The event is not related to the request.
The caller can further process the event.
.It Ic "CTRLSEL_RECEIVED"
The selection have been successfully converted into all the targets.
All the
.Fa "buffer"
members of the
.Ft "struct CtrlSelTarget"
structures in the array given to
.Fn "ctrlsel_request"
have been allocated and set to the selection content in that target.
The
.Fa "bufsize" ,
.Fa "format" ,
.Fa "nitems" ,
and
.Fa "type"
members are set to the size in bytes of the content, format of the
content, number of items and type of the content, respectively.
The caller should not further process the event.
The caller can then use the
.Fa "buffer" ,
and must
.Xr free 3
it when done with it.
.It Ic CTRLSEL_INTERNAL
The selection has been partially converted into the targets.
The caller should not further process the event.
.It Ic CTRLSEL_ERROR
An error has occurred during the selection conversion.
The caller should not further process the event.
Any allocated
.Fa "buffer"
is freed by the function, so the caller should not free it.
.El
.Pp
The
.Fn "ctrlsel_cancel"
function cancels the selection conversion represented by the
.Fa "context" ,
terminates any incremental transference in progress,
and frees any allocated buffer.
.Pp
The
.Fn "ctrlsel_setowner"
function asks the
.Xr Xserver 1
represented to by
.Fa "display"
to own the
.Fa "selection"
in name of the given
.Fa "window" ,
so it can provide the contents of all
.Fa "targets" .
If the
.Fa "selection"
is a manager selection, the
.Fa "ismanager"
argument must be set to nonzero.
This function also fills
.Fa "context"
with data to be passed to the
.Fn "ctrlsel_send"
and
.Fn "ctrlsel_disown"
functions.
It returns nonzero on success or zero on error.
.Pp
The
.Fn "ctrlsel_send"
function filters the X event pointed to by
.Fa "event" ,
checks whether it is related to the
.Fa "context"
previously filled in by
.Fn "ctrlsel_setowner" ,
and sends the converted selection to any requestor client.
One of the following enum constants is returned:
.Bl -tag -width Ds
.It Ic "CTRLSEL_NONE"
The event is not related to the ownership.
The caller can further process the event.
.It Ic "CTRLSEL_INTERNAL"
The selection is converted for a requestor client who have requested the selection.
The caller should not further process the event.
.It Ic "CTRLSEL_LOST"
The selection ownership has been lost.
The caller should not further process the event.
.El
.Pp
The
.Fn "ctrlsel_disown"
function cancels the selection ownership represented by the
.Fa "context" ,
and terminates any incremental transference in progress.
This function does not free any buffer.
.Sh STRUCTURES
The
.Ft "struct CtrlSelTarget"
structure contains:
.Bd -literal -offset indent
struct CtrlSelTarget {
	Atom            target;
	Atom            type;
	int             format;
	unsigned long   nitems;
	unsigned long   bufsize;
	unsigned char  *buffer;
};
.Ed
.Pp
A
.Ft "struct CtrlSelTarget"
structure
could be set manually by the programmer; however it is recommended to use the
.Fn ctrlsel_filltarget
as explained earlier.
The structure members must be  as follows:
.Bl -tag -width Ds
.It Fa "target"
The atom identifying the target.
Its value is either defined in
.In "X11/Xatom.h"
or obtained from the
.Xr "XInternAtom" 3
or
.Xr "XInternAtoms"
functions.
.It Fa "type"
The atom identifying the type of the target content.
Its value is usually the same as
.Fa "target" ,
but not always (it depends on the target).
Its value is either defined in
.In "X11/Xatom.h"
or obtained from the
.Xr "XInternAtom" 3
or
.Xr "XInternAtoms"
functions.
.It Fa "format"
The format of each member of the target content.
It should be
.Ic "8"
.Pq Ft "char"
for most
.Fa types
of targets.
Exceptions are types like
.Ic "XA_ATOM"
and
.Ic "XA_WINDOW" ,
which require the
.Ic "32"
.Pq Ft "long"
format; and types for width, height or RGB color values, which require the
.Ic "16"
.Pq Ft "short"
format.
.It Fa "nitems"
The number of items in
.Fa "buffer"
according to the target
.Fa "format".
If format is
.Ic "8" ,
its value is the same as
.Fa "bufsize" .
If the format is
.Ic "16"
or
.Ic "32" ,
it is the number of
.Ft "short"
or
.Ft "long"
(either signed or unsigned) elements in the buffer, respectively;
that is, it is equal to
.Fa bufsize
divided by
.Ic "sizeof(short)"
or
.Ic "sizeof(long)" .
.It Fa "bufsize"
The size in bytes of
.Fa "buffer" .
.It Fa "buffer"
The buffer containing the selection content converted into
.Fa "target" .
.El
.Pp
The contents of the
.Ft "struct CtrlSelContext"
structure contains basically the values provided to the
.Fn "ctrlsel_request"
and
.Fn "ctrlsel_setowner"
functions (that is, the
.Fa "display" ,
.Fa "targets" ,
.Fa "selection" ,
etc).
Its definition can be read by the programmer in the header file,
but it is not relevant for this manual.
.Sh RETURN VALUES
Upon error,
the
.Fn "ctrlsel_request"
and
.Fn "ctrlsel_setowner"
functions return zero; and the
.Fn "ctrlsel_receive"
function returns
.Ic "CTRLSEL_ERROR" .
.Sh EXAMPLES
The following is an example of the implementation of a function requesting the contents of the primary selection into two targets.
The contents of the selection must be received in a loop because the content can be too long for a single transference.
If the request is triggered by an event (for example, the user pressed the mouse's middle button), the variable
.Fa "time"
must be the timestamp of the event that caused it
(for example, in a
.Xr XButtonEvent 3
event).
If the request is not triggered by an event, the value
.Ic "CurrentTime"
must be given instead.
.Bd -literal -offset indent
struct CtrlSelContext context;
struct CtrlSelTarget targets[2];
XEvent event;
Display *display;
Window window;
Atom utf8, html;
Time time;

/* step 0: fill targets */
utf8 = XInternAtom(display, "UTF8_STRING", False);
html = XInternAtom(display, "text/html", False);
ctrlsel_filltarget(utf8, utf8, 0, NULL, 0, &targets[0]);
ctrlsel_filltarget(html, html, 0, NULL, 0, &targets[1]);

/* step 1: request selection contents */
if (!ctrlsel_request(display, window, XA_PRIMARY,
                     time, targets, 2, &context)) {
	fprintf(stderr, "warning: could not request selection");
	return;
}

/* step 2: receive selection contents */
for (;;) {
	(void)XNextEvent(display, &event);
	switch (ctrlsel_receive(&context, &event)) {
	case CTRLSEL_NONE:
		/* call event handler */
		break;
	case CTRLSEL_RECEIVED:
		goto done;
	case CTRLSEL_INTERNAL:
		continue;
	case CTRLSEL_ERROR:
		fprintf(stderr, "warning: could not get selection");
		return;
	}
}

/* step 3: process selection contents; and free them */
done:
	printf("plain text: %.*s\n",
	       targets[0].bufsize,
	       targets[0].buffer);
	printf("html text:  %.*s\n",
	       targets[1].bufsize,
	       targets[1].buffer);
	free(targets[0].buffer);
	free(targets[1].buffer);
.Ed
.Pp
The following is an example of the implementation of a function asking for the ownership of the primary selection with two targets.
The contents of the selection must be send to requestors in a loop,
because other clients can request the selection asynchronously at any time.
If the ownership is triggered by an event (for example, the user selected a text with the mouse), the variable
.Fa "time"
must be the timestamp of the event that caused it (for example, in a
.Xr XButtonEvent 3
event).
If the ownership is not triggered by an event, the value
.Ic "CurrentTime" must be given instead.
.Bd -literal -offset indent
struct CtrlSelContext context;
struct CtrlSelTarget targets[2];
XEvent event;
Display *display;
Window window;
Atom utf8, html;
char *plain, *markd;
Time time;

/* step 0: fill targets */
plain = "Hello World!"
markd = "<p>Hello <i>World</i>!</p>"
utf8 = XInternAtom(display, "UTF8_STRING", False);
html = XInternAtom(display, "text/html", False);
ctrlsel_filltarget(utf8, utf8, 8, plain, strlen(plain), &targets[0]);
ctrlsel_filltarget(html, html, 8, markd, strlen(markd), &targets[1]);

/* step 1: ask for selection ownership */
if (!ctrlsel_setowner(display, window, XA_PRIMARY,
                     time, 0, targets, 2, &context)) {
	fprintf(stderr, "warning: could not own selection");
	return;
}

/* step 2: provide selection contents */
for (;;) {
	(void)XNextEvent(display, &event);
	switch (ctrlsel_send(&context, &event)) {
	case CTRLSEL_NONE:
		/* call event handler */
		break;
	case CTRLSEL_INTERNAL:
		continue;
	case CTRLSEL_LOST:
		return;
	}
}

/* step 3: free the contents (not needed here, tho) */
.Ed
.Sh SEE ALSO
.Xr X 1 ,
.Xr xclipd 1
.Rs
.%Q "X Consortium Standard"
.%B "Xlib - C Language X Interface"
.Re
.Rs
.%Q "X Consortium Standard"
.%B "Inter-Client Communication Conventions Manual"
.Re
